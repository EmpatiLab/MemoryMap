{"version":3,"sources":["src/index.ts","src/Map.ts","src/Primitives.ts"],"names":["m","exports","Field","this","Buffer","writeInt32LE","Value","readUInt32LE","writeUInt32LE","UInt"],"mappings":"8DAAAA,EAAA,8bCAAC,EAgCAC,47BChCAC,KAAAC,OAAAC,aAAAC,EAAA,mDAKE,OAAIH,KAAAC,OAAAG,aAAA,iBAKFH,OAAKI,cAAkBF,EAAA,aAR3BL,EAuDAQ,KAAAA","sourcesContent":["export * from \"./Map\";\nexport * from \"./Primitives\";\n","import \"reflect-metadata\";\nimport { Byte } from \"./Primitives\";\n\nexport abstract class Type<T = any> {\n  abstract Read(): T;\n  abstract Write(Value: T): void;\n  static Size: number;\n\n  constructor(public Buffer: Buffer) {}\n\n  _Content?: T;\n\n  Get() {\n    if (!this._Content) this._Content = this.Read();\n    return this._Content;\n  }\n\n  Set(Value) {\n    this.Write(Value);\n    this._Content = Value;\n  }\n}\n\ntype Constructor<T = any> = { new (...args: any[]): T };\n\nexport function Field<T>(Type: Constructor<Type<T>>) {\n  return function(Target, Key: string) {\n    console.log(Key, Type, Target);\n    Reflect.defineMetadata(Key, Type, Target);\n  };\n}\n\nexport default class MemoryMap {\n  static get Size() {\n    return Reflect.getMetadataKeys(this.prototype).reduce(\n      (x, y) => x + Reflect.getMetadata(y, this.prototype).Size,\n      0\n    );\n  }\n\n  constructor(public Buffer: Buffer) {\n    let Index = 0;\n    Reflect.getMetadataKeys(this).forEach(Key => {\n      const C = Reflect.getMetadata(Key, this) as typeof Byte;\n      const I = Index;\n      Index += C.Size;\n      const Ins = new C(this.Buffer.slice(I, I + C.Size));\n      Object.defineProperty(this, Key, {\n        get: Ins.Get.bind(Ins),\n        set: Ins.Set.bind(Ins)\n      });\n    });\n  }\n}\n","import { Type } from \"./Map\";\n\nexport class Byte extends Type<number> {\n  static Size = 1;\n\n  Read() {\n    return this.Buffer.readUInt8(0);\n  }\n\n  Write(Value) {\n    this.Buffer.writeUInt8(Value, 0);\n  }\n}\nexport class Short extends Type<number> {\n  static Size = 2;\n\n  Read() {\n    return this.Buffer.readInt16LE(0);\n  }\n\n  Write(Value) {\n    this.Buffer.writeInt16LE(Value, 0);\n  }\n}\nexport class UShort extends Type<number> {\n  static Size = 2;\n\n  Read() {\n    return this.Buffer.readUInt16LE(0);\n  }\n\n  Write(Value) {\n    this.Buffer.writeUInt16LE(Value, 0);\n  }\n}\nexport class Int extends Type<number> {\n  static Size = 4;\n\n  Read() {\n    return this.Buffer.readInt32LE(0);\n  }\n\n  Write(Value) {\n    this.Buffer.writeInt32LE(Value, 0);\n  }\n}\nexport class UInt extends Type<number> {\n  static Size = 4;\n\n  Read() {\n    return this.Buffer.readUInt32LE(0);\n  }\n\n  Write(Value) {\n    this.Buffer.writeUInt32LE(Value, 0);\n  }\n}\nexport function BString(Size: number) {\n  let Bytes = Math.pow(2, Math.ceil(Math.log2(Math.log2(Size))));\n  if (Bytes < 8) Bytes = 8;\n  const Ix = Bytes / 8;\n  const FnName = `UInt${Bytes}${Bytes === 8 ? \"\" : \"LE\"}`;\n  return class BString extends Type<string> {\n    static Size = Size + Ix;\n\n    Read() {\n      const Length = this.Buffer[`read${FnName}`](0);\n      return this.Buffer.slice(Ix, Ix + Length).toString();\n    }\n\n    Write(Value: string) {\n      const Length = Math.min(Size, Value.length);\n      this.Buffer[`write${FnName}`](Length, 0);\n      this.Buffer.write(Value, Ix, Length);\n    }\n  };\n}\n"]}